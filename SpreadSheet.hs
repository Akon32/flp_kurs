--module SpreadSheet where

import Text.ParserCombinators.Parsec
import Text.ParserCombinators.Parsec.Token
import Text.ParserCombinators.Parsec.Expr
import Text.ParserCombinators.Parsec.Language
import Text.ParserCombinators.Parsec.Perm

import Char
import IO
import List
import System

main::IO()
main = getArgs >>= run
run p | p==[] || html = do s<-getContents
                           hPutStr stdout $ toStr s
                           hPutStr stderr $ toErr s
      where res = evalRules.table2rules.str2table
            toStr = (if html then table2html else table2str).rules2table.res
            toErr = unlines.rules2errList.res
            html = p==["--html"]
run ["--help"] = putStrLn$"SpreadSheet\nAuthor - Alexander Konovalov (2010)\n"
                  ++ "Usage:\n"
                  ++ "\tSpreadSheet\n"
                  ++ "\tSpreadSheet [<input_file] [>output_file] [2>errors]\n"
                  ++ "\tSpreadSheet --trees\n"
                  ++ "\tSpreadSheet --html"
run ["--trees"] = getContents >>= putStr.unlines. map show .table2rules.str2table
run _ = putStrLn "SpreadSheet\nuse SpreadSheet --help to get help"

str2table :: String -> [[String]]
str2table s |null s = [[""]]
            |otherwise = map columns $ lines s
table2str :: [[String]]->String
table2str ss = (concat $ intersperse "\n" ( map (\ls->concat $ intersperse "\t" ls) ss))++"\n"
table2html :: [[String]]->String
table2html a = begin ++ table ++ end
    where begin = "<html><head><title>generated by SpreadSheet</title></head><body>\n"
          end = "</body></html>\n"
          table = "<table>\n"++ concat tbody ++"</table>\n"
          frows = zipWith (++) ths (map (concat . map(\s->"\t<td>"++s++"</td>\n")) a)
          tbody = map (\s->"<tr>\n"++s++"</tr>\n") (concat ("<th></th>\n":take c ths):frows)
          (r,c)=tableSize a
          ths = ["\t<th>"++show x++"</th>\n"|x<-[0..]]

columns = split (/='\t')
split :: (a -> Bool) -> [a] -> [[a]]
split _ [] = []
split f s = first : split f (if null last then [] else tail last)
    where (first,last) = span f s

type Rules= [Rule]
type Rule = ((Int,Int),Formula)

table2rules :: [[String]] -> Rules
table2rules sss = concat $ map f2 (numerate sss)
    where numerate = zip [0..]
          f2 (r,ss) = map (\(c,s)->((r,c),str2formula s)) (numerate ss)

rules2table::Rules->[[String]]
rules2table rls=map (map formula2str) r2tf 
    where
        r2tf = foldl (\mt (cell,v)->write mt cell v) emptyTable rls
        write mt (r,c) val = wtl mt r (wtl (mt!!r) c val)
        wtl xs ind x = take ind xs ++ x : drop (ind+1) xs
        emptyTable = take rows $repeat $take cols $repeat Empty
        (rows,cols)=tableSizeR rls
rules2errList::Rules->[String]
rules2errList rls = filter (not.null)(map err rls)
    where err (cl,Error str) = " Error in "++(formatCell(toCell cl))++":\n"++str
          err _ = ""
          
formatCell :: Formula->String
formatCell (Cell r c)="Cell("++(show r)++","++(show c)++")"

tableSizeR :: Rules -> (Int,Int)
tableSizeR rls = (rows+1,cols+1) 
    where 
        rows = foldl1 max $ map (fst.fst) rls
        cols = foldl1 max $ map (snd.fst) rls
tableSize ::[[a]]->(Int,Int)
tableSize t = (length t, foldl1 max $map length t)

findFormula :: Rules->(Int,Int)-> Formula
findFormula rs c = case filter (\(c',frm)->c'==c) rs of
                        [(_,frm)]-> frm
                        _ -> Empty

findFormulaByCell :: Rules->Formula-> Formula
findFormulaByCell rs ce@(Cell r c) = findFormula rs (fromCell ce)

evalRules :: Rules -> Rules
evalRules rls = map (\(cell,frm)->(cell,eval (rls,[cell]) frm)) rls

str2formula [] = Empty
str2formula s = parseFormula s
formula2str :: Formula->String
formula2str Empty = ""
formula2str (Text s) = s
formula2str (Value v) = show v
formula2str (Error e) = "#Error"

--module Parsing(parseFormula)  where

parseFormula :: String -> Formula
parseFormula s = case parse formula "" s of
                   Right f -> f
                   Left err -> Error (show err)
                               
opTable :: [[Operator Char a Formula]]
opTable   = [ [prefix "-" ]
            , [binary "**" AssocLeft]
            , [binary "*" AssocLeft, binary "/" AssocLeft ]
            , [binary "+" AssocLeft, binary "-"   AssocLeft ]
            ]

pfunc :: String -> (Formula->Formula)
pfunc name = \f1 -> Call name [f1]
pfunc2 :: String -> (Formula->Formula->Formula)
pfunc2 name = \f1 f2 -> Call name [f1,f2]

tkns :: TokenParser a
tkns = makeTokenParser javaStyle

binary  name assoc = Infix  (do{ reservedOp tkns name; return (pfunc2 name)}) assoc
prefix  name       = Prefix (do{ reservedOp tkns name; return (pfunc name)})
-- [!] "Postfix" отсутствует в parsec3
postfix name       = Postfix(do{ reservedOp tkns name; return (pfunc name)})

formula :: GenParser Char a Formula
formula = do eof
             return Empty
      <|> do char '='
             x<-expr
             eof
             return x
      <|> do x<-many anyChar
             eof
             return (Text x)
expr,term :: GenParser Char a Formula
expr = buildExpressionParser opTable term

term =  val <|> str <|> parens tkns expr <|> call

call,str,val :: GenParser Char a Formula
call = do id<-identifier tkns
          lst<-callArgList
          return (Call id lst)
callArgList :: GenParser Char a [Formula]
callArgList = parens tkns (commaSep1 tkns ( expr )) <|> return []
str = do s<-stringLiteral tkns
         return (Text s)
val = do v<-naturalOrFloat tkns
         case v of
            Left n -> return (Value (fromInteger n))
            Right f -> return (Value f)

--module Formula where

data Formula = Empty
             | Value Double
             | Text String
             | Cell Int Int
             | Call String [Formula]
             | Error String
             | Diap Int Int Int Int deriving (Show,Eq)

isError,isRecError :: Formula -> Bool
isError (Error _) = True
isError _ = False
isRecError (Error a) = isPrefixOf "Recurs" a
isRecError _ = False
recError :: (Int,Int)->Formula
recError (r,c) = Error $ "Recursively dependence. Depends on " ++ formatCell (Cell r c)

toCell :: (Int,Int)->Formula
toCell (r,c) = Cell r c
fromCell ::Formula->(Int,Int)
fromCell (Cell r c)=(r,c)

diap2cells :: Formula->[Formula]
diap2cells (Diap x1' y1' x2' y2') = [Cell x y|x<-[x1..x2],y<-[y1..y2]]
    where (x1,x2) = (min x1' x2', max x1' x2')
          (y1,y2) = (min y1' y2', max y1' y2')

callWithRecTest :: (Int,Int) -> [(Int,Int)] -> Formula -> Formula
callWithRecTest rc stack call = 
        if elem rc stack then recError rc
            else case call of 
                e@(Error _) -> if isRecError e then recError rc 
                                 else Error ("caused by error in "++formatCell (toCell rc))
                a -> a

eval :: (Rules,[(Int,Int)]) -> Formula -> Formula
eval (rlt,cls) (Cell r c) = let cc=(r,c) in
        callWithRecTest cc cls (eval (rlt,cc:cls) ( findFormula rlt cc ))

eval rls (Call name args)= evalCall rls name (map (eval rls) args)
eval _ v = v

evalCall :: (Rules,[(Int,Int)]) ->String ->[Formula] -> Formula
evalCall _ _ args | any isError args = head $ filter isError args
evalCall _ "-" [Value a] = Value (-a)
evalCall _ "+" [Value a,Value b] = Value (a + b)
evalCall _ "+" [Text a,Text b] = Text (a ++ b)
evalCall _ "-" [Value a,Value b] = Value (a - b)
evalCall _ "*" [Value a,Value b] = Value (a * b)
evalCall _ "/" [Value a,Value b] = Value (a / b)
evalCall _ "**" [Value a,Value b] = Value (a ** b)

evalCall _ "toDeg" [Value a] = Value (a*180/pi)
evalCall _ "toRad" [Value a] = Value (a*pi/180)
evalCall _ "sin" [Value a] = Value (sin a)
evalCall _ "cos" [Value a] = Value (cos a)
evalCall _ "round" [Value a] = Value (fromInteger $ round a)
evalCall _ "round" [Value a,Value n] = Value ( rn0 (a * k)/k)
    where k = 10.0 ** rn0 n
          rn0 = fromInteger . round
evalCall _ "pi" [] = Value (pi)

evalCall _ "mid" [Text s,Value n] |double2int n >=0 = Text (drop (double2int n) s)
evalCall _ "mid" [Text s,Value n,Value len] |valid n && valid len = 
        Text (take (double2int len)(drop (double2int n) s))
    where valid t= double2int t >=0
evalCall _ "left" [Text s,Value n] |double2int n >=0= Text (take (double2int n) s)
evalCall _ "right" [Text s,Value n] |double2int n >=0 = Text $reverse (take (double2int n) (reverse s))
evalCall _ "reverse" [Text s] = Text (reverse s)

--функции для диапазонов
evalCall rls "sum" args = case filter isError flatten of
                            []-> foldr1 (\a b->evalCall rls "+" [a,b]) flatten
                            (e:_)->e
    where flatten = filter(/=Empty) $ flat rls args
evalCall rls "count" [v,d@(Diap _ _ _ _)] = lenInValue $ filter(==v)(flat rls [d]) 
evalCall rls "count" [d@(Diap _ _ _ _)] = lenInValue $ filter(/=Empty) (flat rls [d])
evalCall rls "avg" a@[(Diap _ _ _ _)] = 
        evalCall rls "/" [evalCall rls "sum" a, evalCall rls "count" a]

--конструкторы ячейки и диапазона
evalCall rls "Cell" [Value r',Value c']= eval rls (Cell r c)
        where (r,c) = (double2int r',double2int c')
evalCall rls "Diap" [Value r1,Value c1,Value r2,Value c2]= 
        eval rls $ Diap (double2int r1)(double2int c1)(double2int r2)(double2int c2)
--индексы текущей ячейки
evalCall (_,(r,_):_) "Row" []=Value $ int2double r
evalCall (_,(_,c):_) "Col" []=Value $ int2double c
--копирование формулы

evalCall (rlt,st@(s:ss)) "Copy" [Value r',Value c']= 
        callWithRecTest rc st (eval (rlt,s:rc:ss) $ findFormula rlt rc) 
    where rc = (double2int r',double2int c')

--сообщение об ошибке, если подходящей функции не найдено
evalCall _ name args = Error ("Call \""++ name ++"\" with arguments "++(show args)++" not implemented")

double2int :: Double->Int
double2int = fromInteger . round 
int2double :: Int -> Double
int2double = fromInteger . toInteger
lenInValue :: [a]->Formula
lenInValue = Value . int2double . length
flat :: (Rules,[(Int,Int)])->[Formula]->[Formula]
flat rls [] = []
flat rls (d@(Diap _ _ _ _):xs) = map (eval rls) (diap2cells d) ++ flat rls xs
flat rls (a:xs) = (eval rls a):flat rls xs


